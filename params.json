{
  "name": "Microorm.Dapper.Repositories",
  "tagline": "Repository for CRUD operations",
  "body": "# MicroOrm.Dapper.Repositories\r\n\r\n[![Latest version](https://img.shields.io/nuget/v/MicroOrm.Dapper.Repositories.svg)](https://www.nuget.org/packages/MicroOrm.Dapper.Repositories)  [![License MIT](https://img.shields.io/badge/license-MIT-green.svg)](https://opensource.org/licenses/MIT) [![Build status](https://ci.appveyor.com/api/projects/status/5v68lbhwc9d4948g?svg=true)](https://ci.appveyor.com/project/phnx47/microorm-dapper-repositories)\r\n\r\nIf you like your code runs fast, probably you know about Micro ORMs.\r\nThey are simple and one of their main goals is be the fastest way to execute your SQL sentences on your data repositories.\r\nHowever, for some of them you need to write your own SQL sentences. This is the case of the most popular Micro ORM [Dapper](https://github.com/StackExchange/dapper-dot-net)\r\n\r\nThe idea of this tool is to abstract the generation of the SQL sentence for CRUD operations based on each POCO class \"metadata\".\r\nWe know there are plugins for both Micro ORMs to implement the execution of this kind of tasks,\r\nbut that's exactly the difference of this tool. The \"SQL Generator\" is a generic component\r\nthat generates all the CRUD sentences for a POCO class based on its definition with the possibility to override the way the SQL generator builds each sentence.\r\n\r\nI tested this with MSSQL, PostgreSQL and MySQL .\r\n\r\n\tPM> Install-Package MicroOrm.Dapper.Repositories\r\n\r\nGoals\r\n-----\r\n*  Avoid writing SQL.\r\n*  Avoid possible overwhelming of your application by using Reflection on each CRUD operation execution.\r\n*  Abstract the SQL generation process and reuse the same implementation with both Micro ORMs [Dapper](https://github.com/StackExchange/dapper-dot-net)\r\n\r\nMetadata attributes\r\n-------------------\r\n\r\n###\t[Key]\r\nFrom System.ComponentModel.DataAnnotations\r\n\r\n###\t[Table]\r\nFrom System.ComponentModel.DataAnnotations.Schema - By default the database table name will match the model name but it can be overridden with this.\r\n\r\n### [Column]\r\nFrom System.ComponentModel.DataAnnotations.Schema - By default the column name will match the property name but it can be overridden with this.\r\n\r\n### [NotMapped]\r\nFrom System.ComponentModel.DataAnnotations.Schema - For \"logical\" properties that does not have a corresponding column and have to be ignored by the SQL Generator.\r\n\r\n###\t[Status]\r\nFor tables that implements \"logical deletes\" instead of physical deletes. This attribute can decorate only `enum` properties and one of the possible values for that enumeration has to be decorated with the \"Deleted\" attribute\r\n\r\n###\t[Deleted]\r\nBrother of the previous attribute. Use this to decorate the enum value that specifies the logical delete value for the status property.\t\r\n\r\n### [Identity]\r\nUse for identity key.\r\n\r\nSome notes\r\n----------\r\n\r\n*  By default the SQL Generator is going to map the POCO name with the table name, and each public property to a column.\r\n*  If the `Status` is used on a certain POCO, the \"delete\" sentence will be an update instead of a delete.\r\n*  Complex primary keys are supported.\r\n\r\nSQL Sentences\r\n=============\r\n\r\nLets see some SQL sentences examples that this tool will create. \"Users\" POCO:\r\n\r\n\t[Table(\"Users\")]\r\n\tpublic class User\r\n\t{\r\n\t\t[Key]\r\n\t\t[Identity]\r\n\t\tpublic int Id { get; set; }\r\n\t\t\r\n\t\tpublic string Login { get; set;}\r\n\t\t\r\n\t\t[Column(\"FName\")]\r\n\t\tpublic string FirstName { get; set; }\r\n\t\t\r\n\t\t[Column(\"LName\")]\r\n\t\tpublic string LastName { get; set; }\r\n\t\t\r\n\t\tpublic string Email { get; set; }\r\n\t\t\r\n\t\t[Status]\r\n\t\tpublic UserStatus Status { get; set; }\r\n\t\t\r\n\t\t[NotMapped]\r\n\t\tpublic string FullName\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\treturn string.Format(\"{0} {1}\", FirstName, LastName);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic enum UserStatus\r\n\t{\r\n\t    Active = 0,\r\n\t\r\n\t    Inactive = 1,\r\n\t\r\n\t    [Deleted]\r\n\t    Deleted = 2\r\n\t}\r\n\t\r\nImplements the repository:\r\n\r\n    public class UserRepository : DapperRepository<User>\r\n    {\r\n\r\n        public UserRepository(IDbConnection connection, ISqlGenerator<User> sqlGenerator)\r\n            : base(connection, sqlGenerator)\r\n        {\r\n\r\n\r\n        }\r\n    }\r\n    \r\nSimple as that, we have defined a fully functional data repository for the \"User\" POCO. Because the inheritance pattern we are doing here, both repository contract and repository implementation contains this functions:\r\n\r\n        bool Delete(TEntity instance);\r\n        \r\n        Task<bool> DeleteAsync(TEntity instance);\r\n        \r\n        TEntity Find(Expression<Func<TEntity, bool>> expression);\r\n        \r\n        IEnumerable<TEntity> FindAll();\r\n        \r\n        IEnumerable<TEntity> FindAll(Expression<Func<TEntity, bool>> expression);\r\n        \r\n        Task<IEnumerable<TEntity>> FindAllAsync();\r\n        \r\n        Task<IEnumerable<TEntity>> FindAllAsync(Expression<Func<TEntity, bool>> expression);\r\n        \r\n        Task<TEntity> FindAsync(Expression<Func<TEntity, bool>> expression);\r\n        \r\n        bool Insert(TEntity instance);\r\n        \r\n        Task<bool> InsertAsync(TEntity instance);\r\n        \r\n        bool Update(TEntity instance);\r\n        \r\n        Task<bool> UpdateAsync(TEntity instance);\r\n\r\nExample:\r\n\r\n    var user = await userRepository.FindAsync(x => x.Id == 5);\r\n    \r\n    var allUsers = await userRepository.FindAllAsync(x => x.AccountId == 3 && x.Status != UserStatus.Deleted); // all users for 3 account and not deleted\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}